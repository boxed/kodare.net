<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>When DRY fails</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">When DRY fails</h1>
</header>
<section data-field="subtitle" class="p-summary">
Don’t Repeat Yourself, or DRY, is one of the core principles of programming. It’s part of what makes software powerful: it’s avoiding…
</section>
<section data-field="body" class="e-content">
<section name="092c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bcf8" id="bcf8" class="graf graf--h3 graf--leading graf--title">When DRY fails</h3><p name="14b2" id="14b2" class="graf graf--p graf-after--h3">Don’t Repeat Yourself, or DRY, is one of the core principles of programming. It’s part of what makes software powerful: it’s avoiding duplication of effort when writing the code, but it also makes sure that when a bug is found it’s fixed everywhere. It also applies to data: if you need to change something, you want to be sure you’ve changed it, and not just one copy (this is sometimes called “single source of truth”). It’s generally agreed to be A Good Thing (it can be misused, but let’s leave that for now).</p><h3 name="c589" id="c589" class="graf graf--h3 graf-after--p">But what if you can’t be DRY?</h3><p name="e1f1" id="e1f1" class="graf graf--p graf-after--h3">There are many situations where DRY just isn’t feasible. Here are some:</p><ul class="postList"><li name="10b9" id="10b9" class="graf graf--li graf-after--p">There are serious performance implications</li><li name="8852" id="8852" class="graf graf--li graf-after--li">It makes the code more complex, not less</li><li name="48cd" id="48cd" class="graf graf--li graf-after--li">You need to keep some data in many places for redundancy (backups or cloud storage for example) </li><li name="79a7" id="79a7" class="graf graf--li graf-after--li">You need the same data/code in different programming languages</li><li name="ccca" id="ccca" class="graf graf--li graf-after--li">The data/code is spread over multiple companies</li></ul><p name="3093" id="3093" class="graf graf--p graf-after--li">Whatever the reason may be, it happens and it’s not always avoidable.</p><p name="f8cf" id="f8cf" class="graf graf--p graf-after--p">The problem with DRY as a principle is that it lacks an else clause. It’s like:</p><pre name="4bb7" id="4bb7" class="graf graf--pre graf-after--p">if feasible:<br>    DRY!</pre><p name="eeaa" id="eeaa" class="graf graf--p graf-after--pre">This type of code should make you go WAT, but when it’s taught in school in the form of English we often miss the glaring hole in the principle: what about the else clause? What do we do when the DRY principle can’t be applied? </p><h3 name="3c23" id="3c23" class="graf graf--h3 graf-after--p">DRYER (DRY Else Reconcile)!</h3><p name="162c" id="162c" class="graf graf--p graf-after--h3">So let’s fix the code:</p><pre name="9451" id="9451" class="graf graf--pre graf-after--p">if feasible:<br>    DRY!<br>else:<br>    reconcile!</pre><p name="3d8b" id="3d8b" class="graf graf--p graf-after--pre">When DRY fails, you reconcile. The simplest form of a reconciliation is to just write a test that reads data A and data B and fails with a diff if they are out of sync. The data doesn’t need to be identical (and probably can’t be, otherwise it wouldn’t be a DRY violation in the first place), so the test will need to transform A and B into some common format to be able to compare.</p><p name="f4bc" id="f4bc" class="graf graf--p graf-after--p">Notice how the last paragraph always talks about data, never code. It’s because code is a pain to reconcile, but data is fairly easy. If your code isn’t declarative when you have a DRY violation you might be in trouble. Reconciling code can be having a great test suite (100% coverage, 100% mutation tested ideally) that you can run on both pieces of code. </p><h3 name="6706" id="6706" class="graf graf--h3 graf-after--p">These are not reconciliations</h3><p name="b176" id="b176" class="graf graf--p graf-after--h3">I’ll start with some things that are not valid reconciliation methods. </p><ul class="postList"><li name="fdca" id="fdca" class="graf graf--li graf-after--p">Synchronization is not reconciliation. It never checks the full state of the data, instead monitoring for add/delete/change and propagating those. This isn’t good enough because you will lose an event and now you’re out of sync and you won’t recover. Sync is good for fast change propagation but you need periodic full reconciliation too. </li><li name="7f93" id="7f93" class="graf graf--li graf-after--li">Copying the entire dataset from A to B, overwriting Bs data is not reconciliation. It can work, but it can hide problems you probably should look at. Like why did B diverge when A was unchanged? It can also be a usability problem because someone changes B and at some point becomes surprised and frustrated because their changes are now gone. </li><li name="a19b" id="a19b" class="graf graf--li graf-after--li">Being disciplined and always changing both places is not reconciliation. If it’s not done by a computer it won’t work or scale. Never send a man to do a machines job.</li><li name="ae82" id="ae82" class="graf graf--li graf-after--li">Comparing e.g. checksums on the entire dataset and sounding an alarm if they are different is not reconciliation. This might be a good start but reconciliation means saying <em class="markup--em markup--li-em">what</em> is wrong not just <em class="markup--em markup--li-em">that</em> it’s wrong. </li></ul><h3 name="f03b" id="f03b" class="graf graf--h3 graf-after--li">What is reconciliation?</h3><p name="98b1" id="98b1" class="graf graf--p graf-after--h3">Reconciliation is:</p><ul class="postList"><li name="df86" id="df86" class="graf graf--li graf-after--p">Checking <em class="markup--em markup--li-em">all</em> the data</li><li name="4fa3" id="4fa3" class="graf graf--li graf-after--li">Checking it <em class="markup--em markup--li-em">regularly</em> </li><li name="d8d3" id="d8d3" class="graf graf--li graf-after--li">Reporting <em class="markup--em markup--li-em">all</em> discrepancies</li><li name="634e" id="634e" class="graf graf--li graf-after--li">Reporting <em class="markup--em markup--li-em">fine</em> <em class="markup--em markup--li-em">grained</em> discrepancies</li></ul><p name="7e84" id="7e84" class="graf graf--p graf-after--li">Partial reconciliations where you’re missing one or more of the points above can still be hugely useful of course. Start small!</p><h3 name="cd1c" id="cd1c" class="graf graf--h3 graf-after--p">Blame the system, not the user</h3><p name="f8c1" id="f8c1" class="graf graf--p graf-after--h3 graf--trailing">Every time you make a code change and forgot to update some other place that needs to be updated in sync, don’t think “oh silly me, I forgot” but instead “it’s bad that the compilation/tests didn’t fail”. The same goes for data. This type of thinking takes practice, but I think it’s generally a good idea to defaulting to blaming the system when the user screws up. This attitude makes for good systems without lots of sharp edges in the long run.</p></div></div></section>
</section>
<footer><p><a href="https://medium.com/p/6b0a5b605415">View original.</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 9, 2019.</p></footer></article></body></html>